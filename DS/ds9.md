# 9. 우선순위 큐

## 우선순위 큐

우선순위의 개념을 큐에 도입한 자료구조이다.

우선순위 큐는 우선순위가 높은 데이터가 먼저 나가게 된다.

| 자료구조 | 삭제되는 요소 |
| -------- | ----------- |
| 스택 (LIFO) | 가장 최근에 들어온 데이터 |
| 큐 (FIFO) | 가장 먼저 들어온 데이터 |
| 우선순위 큐 | 가장 우선순위가 높은 데이터 |

우선순위 큐는 스택이나 큐로도 구현할 수 있고,
배열, 연결리스트 등의 여러가지 방법으로 구현이 가능한데, 
가장 효율적인 방법은 **히프**(heap)이다.


### 우선순위 큐 추상자료형

```
ADT 8.1 우선순위 큐 추상자료형

- 객체: n개의 element형의 우선 순위를 가진 요소들의 모임
- 연산:
    create() ::= 우선순위 큐를 생성한다.
    init(q) ::= 우선순위 큐 q를 초기화한다.
    is_empty(q) ::= 우선순위 큐 q가 비어있는지를 검사한다.
    is_full(q) ::= 우선순위 큐 q가 가득 차있는지를 검사한다.
    insert(q, x) ::= 우선순위 큐 q에 요소 x를 추가한다.
    delete(q) ::= 우선순위가 가장 높은 요소를 삭제하고 반환한다.
    fine(q) ::= 우선순위가 가장 높은 요소를 반환한다.
```

최소 우선순위 큐는 가장 우선순위가 낮은 요소를 먼저 삭제하고, 
최대 우선순위 큐는 가장 우선순위가 높은 요소를 먼저 삭제한다.

## 우선순위 큐의 구현 방법

| 표현 방법 | 삽입 | 삭제 |
| -------- | ---- | ---- |
| 정렬 안된 배열 | O(1) | O(n) |
| 정렬 안된 연결리스트 | O(1) | O(n) |
| 정렬 된 배열 | O(n) | O(1) |
| 정렬 된 연결리스트 | O(n) | O(1) |
| 히프 | O(logn) | O(logn) |

## 히프

히프는 완전 이진 트리의 일종으로 느슨한 정렬 상태를 유지하는 자료구조이다.

히프는 여러 개의 값들 중 가장 큰 값이나 가장 작은 값을 빠르게 찾아내도록 만들어진 자료 구조이다.

### 히프의 종류

- 최대 히프(max heap):
부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리

`key(부모 노드) >= key(자식 노드)`

- 최소 히프(min heap):
부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리

`key(부모 노드) <= key(자식 노드)`

### 히프의 높이

n개의 노드를 가지고 있는 히프의 높이는?
= log₂n+1

### 히프의 구현

배열을 이용하여 구현(인덱스 1부터 시작)

- 왼쪽 자식노드의 인덱스 = 부모노드 인덱스 * 2
- 오른쪽 자식노드의 인덱스 = 부모노드 인덱스 * 2 + 1
- 부모노드의 인덱스 = 자식노드 인덱스 / 2

### 히프 삽입 연산

1. 추가할 노드를 마지막 노드 뒤에 삽입
2. 부모 노드와 비교
3. 반복

```c
void insert_heap(heap *h, element item)
{
    if(is_full(h))
        error();
    int i;
    i = ++(h->size);
    while((i != 1) && (item > h->heap[i/2]))
    {
        h->heap[i] = h->heap[i/2];
        i /= 2;
    }
    h->heap[i] = item;
}
```

### 히프 삭제 연산

1. 루트 노드 저장 후 삭제
2. 마지막 노드를 루트 노드로 이동
3. 이동한 노드를 자식 노드와 비교
4. 반복
5. 저장한 루트 노드 반환

```c
element delete_heap(heap *h)
{
    element temp, item;
    int i, j;
    
    item = h->heap[1];
    temp = h->heap[(h->size)--];
    i = 1;
    j = 2;
    while(j <= h->size && temp < h->data[j])
    {
        if(h->heap[j+1] && (h->heap[j] < h->heap[j+1]))
            j += 1;
        h->heap[i] = h->heap[j];
        i = j;
        j *= 2;
    }
    h->heap[i] = temp;
    return item;
}
```

## 히프 정렬

```c
void heapSort(element a[], int n)
{
    for(int i=0; i<n; i++) {
        insert_heap(heap, a[i]);
    }
    for(int i=0; i<n; i++) {
        a[i] = delete_heap(heap);
    }
}
```

## 허프만 코드

각 글자의 빈도수로 내용을 코드로 압축

- Huffman code program ([Encoding](./report1.c) / [Decoding](./report2.c))